\documentclass[letterpaper, 10 pt, conference]{ieeeconf}

\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{bm}

\usepackage{amsfonts}
\usepackage[pdftex]{graphicx}
\usepackage{comment}

\usepackage{caption}
\usepackage{subcaption}

%\usepackage{amsthm}
\newtheorem{thm}{Theorem}
\newtheorem{lem}{Lemma}
%\newtheorem{asmp}{Assumption}
%\newtheorem{defn}{Definition}
%\newtheorem{clm}{Claim}

\IEEEoverridecommandlockouts                              % This command is only needed if 
                                                          % you want to use the \thanks command

\overrideIEEEmargins                                      % Needed to meet printer requirements.

\title{\LARGE \bf
Homotopy-aware RRT$^{*}$ : Toward optimal path planning with the consideration of the topology
}

\author{
Daqing Yi, Michael A. Goodrich and Kevin D. Seppi
\thanks{Daqing Yi, Michael A. Goodrich and Kevin D. Seppi are with Department of Computer Science, Brigham Young University, Provo, UT, 84604, USA.
{\tt\small daqing.yi@byu.edu, mike@cs.byu.edu, kseppi@cs.byu.edu} }
}

\begin{document}


\maketitle
\thispagestyle{empty}
\pagestyle{empty}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
The topology factor of the paths is often ignored in the task planning.
Because it is difficult to be modeled in the optimal motion planning problems, especially when it is not a hard constraint.
In plenty of the tasks, the goal is not only to optimize some objective, i.e. ``go quickly from A to B avoiding C'', but also contains some topological constraints.
In this paper, we propose HA-RRT$^{*}$, a homotopy-aware RRT$^{*}$, that explores the planning space for optimal solutions with the consideration of the topology of the paths.
Because the algorithm is aware of the homotopy classes of each branch, it can support sliding autonomy for different levels of human's intent on the path topology.
Thus, a clear intent on the path topology provides the homotopic constraint, which reduces the working space of the optimal search;
a vague intent on the path topology can be identified by comparing the optimal solutions in different homotopy classes.
We provides the applications to show how it works in different cases and the corresponding theoretic analyses.
\end{abstract}

\begin{comment}
six pages
\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
\label{sec:intro}

Optimality has been the most important heuristic in planning motions for the robots.
An optimization problem is usually modeled by using the metric that measures the task performance.
As the task supervisor, it is very essential that the human's intent can be correctly and precisely modeled into the optimization problem.
Thus, the planned solution for the robot can be the one matches the human's intent.
In planning the robot's motion in a task, the most common way of modeling the intent is by defining single objective~\cite{6974170} or multiple objectives~\cite{yi2014supporting}.
The generated path is a solution that optimizes the given objectives, for example, minimizing the Euclidean distance.
Not all types of the human's intents can be easily modeled using measurable objectives.
The ``shape'' of the planned path, which indicates the topology in the environments with complex obstacles, is one of them.
Such intent can be a hope of avoiding visiting some regions, a will of moving around some objects or a preference of how the motion is like.
Some of the intents are defined as constraints, for example via-point constraint~\cite{} or temporal logic constraint~\cite{}, in the optimization problems.
This method won't work when there is only preference on the ``shape'' of the paths instead of hard constraint.
At the same time, the preference on the ``shape'' of the paths might also be fuzzy for the human to describe.

\emph{Homotopy} is commonly used to indicate the inherent topological similarity of the paths.
Given two paths, if one can be deformed into the other without encroaching any obstacle, they are said to be \emph{homotopic}~\cite{Hernandez201544}.
Thus, we can have a \emph{homotopy class}, in which any two paths are homotopic.
Given the start position and the end position, the obstacles in the map can determine several homotopy classes.
The homotopy of the paths can then be used for modeling the human's intent on the path ``shape''. 


Now in a path planning problem, a human task supervisor is defining a task for a robot.
The task is needed to be modeled so that the robot can understand and plan for execution.
Assume the objective is only reaching to a target quickly, there can be several levels of how clear his intent is.
\begin{enumerate}
\item \emph{I only want the planned path sequentially visiting several regions.}
It means that the planned path is constrained in one homotopy class.
The homotopy class becomes the constraint of the optimization problem~\cite{Hershberger199463}.
%This homotopy class could be defined from a human initialized reference path.
\item \emph{I know some regions that have to be visited and some regions could not be reached.}
There can exist several homotopy classes that can satisfy the requirement defined by the required regions and forbidden regions.
In this case, the homotopic constraint becomes several homotopy classes instead of only one.
\item \emph{I feel some path ``shape'' is better when comparing with another ``shape''.}
It indicates that the human has preference on different homotopy classes.
If the preference on the homotopy classes can be modeled as one objective, the non-dominant solutions can be found.
Thus the human could select one from the Pareto optimal paths.
\item \emph{I should have preference but it is hard for me to tell.}
In this case, the human's preference could be identified through interactive process.
Another straightforward way is that the planning algorithm provides the best solution of each homotopy class to the supervisor.
The supervisor can then select one that satisfy his/her intent.
\end{enumerate}

In this paper, we propose a homotopy-aware RRT$^{*}$ that awares the homotopy class each branch belongs to while exploring the planning space by optimal heuristic.
It could assist the planner finding the intended optimal path in considering the homotopy.
We review the relevant work in section \ref{sec:related_work}.
We introduce the algorithm in section \ref{sec:algorithm} and analyze the algorithm in section \ref{sec:analysis}.
The proposed algorithm is applied into different level of sliding autonomy in section \ref{sec:application}.

\section{Related work}
\label{sec:related_work}

Homotopy reveals the similarity between two paths.
It can be used to determine the similarity between a reference path and a normal path, or classify the paths into different classes.
Homotopy-based path planning depends on the determination of the homotopy equivalence of two paths, which is usually computationally expensive.

Voronoi diagram is naturally introduced to assist determining the homotopy classes, but it shows limitation on finding some paths in some cases~\cite{banerjee2013framework}.
Particularly, it cannot support obstacles of complicated shapes well.
By algebraic topology, the path of same homotopy class can be determined by using orientable band~\cite{Hershberger199463}.
Similarly, the problem and complexity come when the shapes of the obstacles are not smooth and convex.
Semi-algebraic cuts are used to converting the path into ``word'' so that the homotopic equivalence can be compared~\cite{Grigoriev:1998:PAS:281508.281528}.
The Cauchy Integral theorem has been introduced to determine homotopy class by marking the positions in the obstacles as undefined~\cite{AAAI101920}.
Because the map is discretized, the computation cost expands greatly if the obstacles are reasonably approximated by the cells.

Sampling-based path planning has been an effective and popular tool.
The idea of homotopy has also been imported here.
By homotopic redundancy, the paths from PRM could be compared by the homotopy classes~\cite{1041613}.
By dividing the space using the rays crossing each obstacle, reference frames could be used to represent the paths into canonical sequences~\cite{Hernandez201544}.
In this way, the extending process of the graph structure keeps tracking the homotopy class of the new branch so that the exploration process can be constrained by some homotopy classes.

In order to accelerate the exploration process, bidirectional RRT has been introduced to accelerate the exploration process.
In the optimal sampling process, the optimality is still preserved~
\cite{Jordan.Perez.ea:CSAIL13}~\cite{starek2014bidirectional}.
With two trees exploring from two directions, we can have the optimal cost-to-go and the optimal cost-to-arrive at different position.
This guarantee the optimality search with the homotopical constraint.
We introduce the homotopy-aware bidirectional RRT$^{*}$ to support different level of intent on topology from the planner.

\section{Homotopy-aware RRT$^{*}$}
\label{sec:algorithm}

In this section, we adopt the Jenkin's method ~\cite{Hernandez201544} to generate reference frames given a map with obstacles.
With the generated reference frames, we could import the bidirectional RRT$^{*}$ to accomplish the homotopy-aware exploration process.

The generation process of the reference frames is given in Algorithm \ref{alg:harrt:init_ref_frames}.

\begin{algorithm}[hbtp]
	\begin{algorithmic}[1]
		\State $ \bm{R} = \emptyset $
		\For{\textbf{each} $ B_{k} \in \bm{B} $ }
			\State $ b_{k} $ $ \leftarrow $ Sample from $ B_{k} $
			\State $ \bm{b} \leftarrow \bm{b} \cup b_{k} $
		\EndFor
		\While{ $ \exists b_{k}, b_{k'} , c \in $ \Call{Line}{ $ b_{k}, b_{k'} $ } }
			\State $ c \leftarrow  $ Sample from $ \bm{X}_{free} $
		\EndWhile
		\For{\textbf{each} $ b_{k} \in \bm{b} $ }
			\State $ \alpha_{k} \leftarrow $ \Call{Ray}{ $ b_{k}, c - b_{k} $ }
			\State $ \beta_{k} \leftarrow $ \Call{Ray}{ $ b_{k}, b_{k} - c $ }
			\State $ \bm{\alpha} \leftarrow \bm{\alpha} \cup \alpha_{k} $
			\State $ \bm{\beta} \leftarrow \bm{\beta} \cup \beta_{k} $			
		\EndFor
		\For{\textbf{each} $ \alpha_{k} \in \bm{\alpha} $}
			\State $ \{ \alpha_{k_{m}} \} \leftarrow $ \Call{Intersect}{$ \alpha_{k}, \bm{B} $}
			\State $ \bm{R} \leftarrow \bm{R} \cup \{ \alpha_{k_{m}} \} $
		\EndFor
		\For{\textbf{each} $ \beta_{k} \in \bm{\beta} $}
			\State $ \{ \beta_{k_{m}} \} \leftarrow $ \Call{Intersect}{$ \beta_{k}, \bm{B} $}
			\State $ \bm{R} \leftarrow \bm{R} \cup \{ \beta_{k_{m}} \} $
		\EndFor
		\Return $ \bm{R} $
	\end{algorithmic}
	\caption{ \textsc{InitRefFrames} ($ \bm{X}_{free} , \bm{B} $) }
	\label{alg:harrt:init_ref_frames}
\end{algorithm} 

\begin{figure}
	\centering
	\begin{subfigure}[t]{0.45\linewidth}
		\centering
		\includegraphics[width=\textwidth]{fig/obs_map.png}
		\caption{Decomposition of the map with obstacles.}
		\label{fig:obs_map:map}
	\end{subfigure}  
	%\\
	\begin{subfigure}[t]{0.5\linewidth}
		\centering
		\includegraphics[width=\textwidth]{fig/obs_topology.png}
		\caption{The generated topological graph.}
		\label{fig:obs_map:topology}
	\end{subfigure}   
	\caption{Map with obstacles.}
	\label{fig:obs_map}
\end{figure}

\begin{itemize}
	\item \textsc{Line}($ p_{1}, p_{2} $):
	Return a line that defined by $ p_{1} $ and $ p_{2} $.
	\item \textsc{Ray}($ p, \vec{d} $):
	Return a ray that starts from $ p $ with direction $ \vec{d}  $.
	\item \textsc{Intersect}( $ r , \bm{B} $ ):
\end{itemize}

\begin{algorithm}
	\begin{algorithmic}[1]
		\State $ i \leftarrow 0 $
		\State $ V_{s} \leftarrow \{ x_{init} \} $; $ E_{s} \leftarrow \emptyset $; $ G_{s} \leftarrow (V_{s}, E_{s}) $
		\State $ V_{g} \leftarrow \{ x_{goal} \} $; $ E_{g} \leftarrow \emptyset $; $ G_{g} \leftarrow (V_{g}, E_{g}) $
		\While{ $ i < N $ }
			\State $ G_{s} \leftarrow $ \Call{Explore}{$ G_{s}, i $}
			\State $ G_{g} \leftarrow $ \Call{Explore}{$ G_{g}, i $}
			\State $ i \leftarrow i + 1 $
		\EndWhile
		\State \Call{ExtractPaths}{$ G_{s}, G_{g} $}
	\end{algorithmic}
	\caption{HA-RRT$^{*}$ ($ x_{init} , x_{goal}  $) }
	\label{alg:harrt}
\end{algorithm}

\begin{algorithm}
	\begin{algorithmic}[1]
		\State $ x_{rand} \leftarrow $ \Call{ Sample }{$ i $} ;
		\State $ x_{nearest} \leftarrow $ \Call{Nearest}{$ G, x_{rand} $}
		\State $ x_{new} \leftarrow $ \Call{Steer}{$ x_{nearest}, x_{rand},\eta $}
		\If{ \Call{ObstacleFree}{$ x_{nearest}, x_{new} $} }
			\State $ G \leftarrow $ \Call{ Extend }{$ G, x_{new}, x_{\it nearest} $}
		\EndIf
		\Return $ G $
	\end{algorithmic}
	\caption{ \textsc{Explore}($ G, i $) }
	\label{alg:harrt:explore}
\end{algorithm}

\begin{algorithm}
	\begin{algorithmic}[1]
		\State $ V' \leftarrow V $; $ E' \leftarrow E $
		\State $ V' \leftarrow V' \cup \{ x_{new} \} $
		\State $ x_{min} \leftarrow x_{nearest} $
		\State $ X_{near} \leftarrow $ \Call{Near}{$ G, x_{new}, | V | $}
		\State $ s \leftarrow $ \Call{STR}{$x_{new}$} $ \cup $ \Call{CRF}{$ ( x_{new}, x_{near} ), \bm{B} $}
		\If{\Call{HomotopyCheck}{$ s $}}
			\For{\textbf{each} $ x_{near} \in X_{near} $ }
				\If{ \Call{ObstacleFree}{$ x_{new} , x_{near} $} }
					\State $ c' \leftarrow $ \Call{Cost}{$ x_{near} $} $ + c( $ \Call{Line}{$ x_{near}, x_{new} $} $ ) $ 
					\If{ $ c' < $ \Call{Cost}{$ x_{new} $} }
						\State $ x_{min} \leftarrow x_{near} $
					\EndIf
				\EndIf
			\EndFor
		\Else
		    \State \Return $ G' = (V', E') $ 		
		\EndIf
		\State $ E' \leftarrow E' \cup \{ ( x_{min}, x_{new} ) \} $
		\For{\textbf{each} $ x_{near} \in X_{near} \setminus \{ x_{min} \} $ }
			\If{\Call{ObstacleFree}{$ x_{new} , x_{near} $} and \Call{Cost}{$ x_{near} $} $ > $ \Call{Cost}{$ x_{new} $} + c(\Call{Line}{$ x_{new}, x_{near} $}) }
			    \State $ s \leftarrow $ \Call{STR}{$x_{new}$} $ \cup $ \Call{CRF}{$ ( x_{new}, x_{near} ), \bm{B} $}
			    \If{\Call{HomotopyCheck}{$ s $}}
					\State $ x_{parent} \leftarrow $ \Call{Parent}{$ x_{near} $}
					\State $ E' \leftarrow E' \setminus \{ ( x_{parent}, x_{near} ) \} $
					\State $ E' \leftarrow E' \cup \{ ( x_{new}, x_{near} ) \} $
					%\State \Call{STR}{$x_{near}$} $ \leftarrow $ \Call{STR}{$x_{new}$} 
					%\State \Call{STR}{$x_{near}$} $ \leftarrow $ \Call{STR}{$x_{near}$} $ \cup $ \Call{CRF}{$ ( x_{new}, x_{near} ), \bm{B} $}
				\EndIf
			\EndIf
		\EndFor
		\Return $ G' = (V', E') $ 
	\end{algorithmic}
\label{alg:harrt:extend}
\caption{ {\sc Extend } ($ G, x_{new}, x_{nearest} $) }
\end{algorithm}

\begin{itemize}
	\item \textsc{CRF}($ l, \bm{R} $):
	Returns the character that represents the crossed reference frames if any.
	\item \textsc{STR}($ x $):	
	\item \textsc{HomotopyCheck}{($ s $)}
\end{itemize}

\begin{algorithm}
	\begin{algorithmic}[1]
		\State $ V_{s,g} \leftarrow $ \Call{SameVertices}{$ G_{s}, G_{r} $}
		\State $ P \leftarrow \emptyset $
		\For{\textbf{each} $ v \in V_{s,g} $ }
			\State $ p_{s} \leftarrow $ \Call{Path}{$ v, G_{s} $}
			\State $ p_{g} \leftarrow $ \Call{Path}{$ v, G_{g} $}
			\State $ p \leftarrow $ \Call{Concatenate}{$  p_{s}, p_{g} $}
			\State $ P \leftarrow P \cup \{ p \} $
		\EndFor
		\Return $ P $
	\end{algorithmic}
	\caption{ \textsc{ExtractPaths}($ G_{s}, G_{r} $) }
	\label{alg:harrt:binding}
\end{algorithm}


\section{Analysis}
\label{sec:analysis}



\subsection{homotopic grammar}

Each path or subpath can be converted into a string, which represents a sequence of characters by crossed reference frames.
The grammar of the strings could be introduced to manage the exploration process and sort the paths into different homotopy classes.

\begin{figure}
	\centering
	\begin{subfigure}[t]{0.45\linewidth}
		\centering
		\includegraphics[width=\textwidth]{fig/feasibility}
		\caption{Feasibility}
		\label{fig:grammar:feasibility}
	\end{subfigure}  
	\begin{subfigure}[t]{0.45\linewidth}
		\centering
		\includegraphics[width=\textwidth]{fig/equivalence}
		\caption{Equivalence}
		\label{fig:grammar:equivalence}
	\end{subfigure}
	\\
	\begin{subfigure}[t]{0.45\linewidth}
		\centering
		\includegraphics[width=\textwidth]{fig/recurring}
		\caption{Recurring}
		\label{fig:grammar:recurring}
	\end{subfigure}  
	\begin{subfigure}[t]{0.45\linewidth}
		\centering
		\includegraphics[width=\textwidth]{fig/repeated_pattern}
		\caption{Equivalence}
		\label{fig:grammar:repeated_pattern}
	\end{subfigure} 
	\caption{Homotopic grammar.}
	\label{fig:grammar}
\end{figure}

\begin{itemize}
\item \textbf{Feasibility}
As the reference frames are connected by the regions, a feasible string follows some grammar defined by the connectivity.

\item \textbf{Equivalence}
Some characters of the reference frames are equivalent in constructing the strings.
All the reference frames contains the center point $ c $ show this property.
The segment crossing those reference frames in any sequence belongs to same homotopy class.


\item \textbf{Recurring character}
Recurring character in a string indicates that the path goes around some obstacles and back to a visited region.


\item \textbf{Repeated pattern}
Repeated pattern shows that the path is back and forth among some regions.

\end{itemize}

\subsection{Optimality with constraint}

We can have the asymptotic optimality with the constraint of via-points.
It is stated in Lemma \ref{lem:optimal_via_point}.

\begin{lem}
\label{lem:optimal_via_point}
Given Assumptions 1 - 3 in \cite{Karaman-RSS-10},
the path concatenated from a path from $ G_{s} $ for $ v $ and a path from $ G_{g} $ for $ v $ converges to the optimal path through $ v $ almost surely. 
\begin{proof}
\end{proof}
\end{lem}




\section{Homotopy-aware optimal path planning}
\label{sec:application}

In this section, we discuss the sliding autonomy in different levels of the human's intent on the topology.

\subsection{Homotopic constraint from a reference path}

Initializing a reference path is an easy and straightforward way of defining the homotopic constraint.

\begin{thm}
\label{thm:constrained_optimality}
Given Assumptions 1 - 3 in \cite{Karaman-RSS-10},
\end{thm}

Figure \ref{fig:reference_path} gives an example.
A user firstly initializes a reference path, which indicates the intended homotopy class.
The exploration of HA-RRT$^{*}$

\begin{figure}
	\centering
	\begin{subfigure}[t]{0.47\linewidth}
		\centering
		\includegraphics[width=\textwidth]{fig/referenceHomotopy.png}
		\caption{Reference path}
		\label{fig:reference_path:reference}
	\end{subfigure}  
	%\\
	\begin{subfigure}[t]{0.47\linewidth}
		\centering
		\includegraphics[width=\textwidth]{fig/homotopicConstrainedRRT.png}
		\caption{RRT$^{*}$ with homotopic constraint}
		\label{fig:reference_path:rrt}
	\end{subfigure}   
	\caption{Homotopic constraint from a reference path.}
	\label{fig:reference_path}
\end{figure}

\subsection{Homotopic constraints from required/forbidden regions}

The constraint can not only be one homotopy class, but also be a set of homotopy classes.
If the user defines \emph{positive (required) regions} and \emph{negative (forbidden) regions}, 
a set of homotopy classes satisfies these constraints can be obtained by searching on the topological graph.

\subsection{Homotopy classes with preference}

The topology can also be soft constraint.
When the user has a preference on some of the homotopy classes or all the homotopy classes,
the preference value of each homotopy class could be assigned.
In this case, the topology can be viewed as a new objective.
Each homotopy class is a value of the variable that represents the topology type.
The variable of the topology type is discrete.
The problem is converted into a two-objective optimization problem.
Because the optimal solution in a homotopy class dominates all other solutions in the homotopy class.
By combining the optimal solutions in all the homotopy classes, we can have the Pareto front of all the solution.

\begin{figure}
	\centering
	\begin{subfigure}[t]{0.47\linewidth}
		\centering
		\includegraphics[width=\textwidth]{fig/homotopyClassRRT.png}
		\caption{Share same exploration space.}
		\label{fig:homotopy_no_pref:all}
	\end{subfigure}  
	%\\
	\begin{subfigure}[t]{0.47\linewidth}
		\centering
		\includegraphics[width=\textwidth]{fig/homotopyClassRRTHalf.png}
		\caption{Split the exploration space.}
		\label{fig:homotopy_no_pref:half}
	\end{subfigure}   
	\caption{Bidirectional RRT$^{*}$.}
	\label{fig:homotopy_no_pref}
\end{figure}

\subsection{Homotopy classes without preference}

Sometimes inherently the user has a mind of the topology preference but feels difficult to describe.
Then, showing the optimal solution of all the homotopy classes helps the user figuring out an ``optimal'' solution that matches his inherent preference.

\begin{figure}
	\centering
	\begin{subfigure}[t]{0.47\linewidth}
		\centering
		\includegraphics[width=\textwidth]{fig/pareto.png}
		\caption{Pareto front with topology preference.}
		\label{fig:homotopy_human_interaction:pareto}
	\end{subfigure}  
	%\\
	\begin{subfigure}[t]{0.47\linewidth}
		\centering
		\includegraphics[width=\textwidth]{fig/navBestInHomotopy.png}
		\caption{Navigate the best solution of each homotopy class.}
		\label{fig:homotopy_human_interaction:all}
	\end{subfigure}   
	\caption{Interactive optimization.}
	\label{fig:homotopy_human_interaction}
\end{figure}


\begin{thm}
\label{thm:homotopy_no_pref:optimal}
Given Assumptions 1 - 3 in \cite{Karaman-RSS-10},

\end{thm}

\subsection{Discussion}

Dilemma between efficiency and scenario support

\subsubsection{Scenario support}

\subsubsection{Efficiency}

\section{Conclusion}
\label{sec:conclusion}

\bibliographystyle{IEEEtran}
\bibliography{reference}

\end{document}